
# 시스템 구현 (.NET Core)

ASP.NET Core 기반 내부 구현을 빠르게 파악할 수 있도록 핵심 설계와 운영 포인트를 요약합니다. 아래 예시는 **형태와 흐름**을 보여 주기 위한 최소 예시이며, 실제 내용과 코드는 이후 채워 넣을 예정입니다.

## 목차
1. Controller - Service - Repository 패턴
2. 캐시 정책 (Cache Aside & Invalidate)
3. 트랜잭션 처리
4. 로그 처리

---

## 1) Controller - Service - Repository 패턴

간단한 책임 분리: `Controller`는 입출력과 메서드 호출, `Service`는 도메인 규칙과 트랜잭션, `Repository`는 데이터 접근에 집중합니다.

```
/src
  /APIServer
    Controllers/
    Services/
      Interfaces/
      Implements/
    Repository/
      Interfaces/
      Implements/
    Models/
```

**Controller 예시**
Controller에서는 API 요청에 대해 적절한 도메인 메서드를 호출하여 처리를 진행하며, 반환 데이터와 결과 코드를 반환합니다.
데이터를 반환해야 하는 경우에는 DB Entity 자체를 반환하지 않고, 클라이언트에서 필요한 데이터로 구성된 DTO를 작성하여 사용합니다.

```csharp
[ApiController]
[Route("api/[controller]")]
public class LoginController(ILogger<LoginController> logger, IAccountService accountService
    , IDataLoadService dataLoadService) : ControllerBase
{
    private readonly ILogger<LoginController> _logger = logger;
    private readonly IAccountService _accountService = accountService;
    private readonly IDataLoadService _dataLoadService = dataLoadService;
    
    /// <summary>
    /// 게임 로그인 요청 API
    /// 세션 인증 : X
    /// 반환 값 :
    /// - 토큰 : 세션 인증이 필요한 API 요청시에 구분 값으로 사용하는 토큰으로, 만료 시간 존재
    /// - 반환 코드 : 로그인 요청 결과 (성공 : ErrorCode.None)
    /// - 게임 데이터 : 유저 데이터, 인벤토리, 퀘스트 정보 등 클라이언트에서 필요한 데이터
    /// </summary>
    [HttpPost]
    public async Task<LoginResponse> LoginAsync([FromBody] LoginRequest request)
    {
        LogInfo(_logger, EventType.Login, "Request Login", new { request });
        
        var login = await _accountService.LoginAsync(request.email, request.password);
        if (login.IsFailed)
        {
            return new LoginResponse { code = login.ErrorCode };
        }

        var dataLoad = await _dataLoadService.LoadGameDataAsync(login.Value.userId);
        if (dataLoad.IsFailed)
        {
            return new LoginResponse { code = dataLoad.ErrorCode };
        }
        
        return new LoginResponse
        {
            authToken = login.Value.authToken,
            gameData = dataLoad.Value
        };
    }
}
```

**Service/Repository 인터페이스**

```csharp
public interface IAccountService
{
    /// <summary> 회원 가입 </summary>
    Task<Result> RegisterAccountAsync(string email, string password);
    
    /// <summary> 로그인 </summary>
    Task<Result<(long userId, string authToken)>> LoginAsync(string email, string password);
}

public interface IAccountDb
{
    /// <summary> 이메일 기반 계정 정보 유무 확인 </summary>
    Task<bool> CheckExistAccountByEmailAsync(string email);
    
    /// <summary> 계정 정보 생성 </summary>
    Task<bool> CreateAccountUserDataAsync(long userId, string email, string password);
    
    /// <summary> 이메일 기반 계정 정보 조회 </summary>
    Task<UserAccount> GetUserAccountByEmailAsync(string email);
}
```

**Service 구현 스케치**
각 도메인 메서드에서는 요청받은 데이터에 대한 처리를 진행하며, try-catch 구문을 필수적으로 추가하여 예외에 대한 처리를 같이 진행합니다.
모니터링 대시보드 등에 메트릭스를 수집해야 하는 곳에서는 finally 문법을 사용하여 메트릭스 정보를 수집합니다.

```csharp
public class AccountService(ILogger<AccountService> logger, IAccountDb accountDb,
    IGameDb gameDb, IMemoryDb memoryDb) : IAccountService
{
    private readonly ILogger<AccountService> _logger = logger;
    private readonly IAccountDb _accountDb = accountDb;
    private readonly IGameDb _gameDb = gameDb;
    private readonly IMemoryDb _memoryDb = memoryDb;
    
    public async Task<Result<(long, string)>> LoginAsync(string email, string password)
    {
        try
        {
            // 계정 조회
            var account = await _accountDb.GetUserAccountByEmailAsync(email);
            if (account is null)
            {
                return Result<(long, string)>.Failure(ErrorCode.CannotFindAccountUser);
            }
            
            // 패스워드 검증
            if (!SecurityUtils.VerifyPassword(account.password, account.salt_value, password))
            {
                return Result<(long, string)>.Failure(ErrorCode.FailedPasswordVerify);   
            }

            // 토큰 발급 + 세션 등록
            var token = SecurityUtils.GenerateAuthToken();
            if (await _memoryDb.RegisterSessionAsync(CreateNewSession(account, token)) == false)
            {
                return Result<(long, string)>.Failure(ErrorCode.FailedRegisterSession);
            }

            return Result<(long, string)>.Success((account.user_id, token));
        }
        catch (Exception ex)
        {
            LogError(_logger, ErrorCode.FailedLogin, EventType.Login, 
                "Failed User Login", new { email, ex.Message, ex.StackTrace });
            return Result<(long, string)>.Failure(ErrorCode.FailedLogin);
        }
    }
}
```

---

## 2) 캐시 정책 (Cache Aside & Invalidate)

읽기는 **Cache-Aside**, 쓰기는 **Invalidate**를 기본으로 합니다. 키 규칙과 TTL을 일관되게 관리합니다.


** 캐시 정책 예시 **
Redis를 활용하는 Memory DB에 우선적으로 접근하고, 데이터가 존재하지 않는 경우 Mysql에 접근하여 데이터를 가져옵니다.
가져온 데이터는 Memory DB에 저장하여 Invalidate 되기 전까지의 데이터 호출을 DB에 대한 접근없이 메모리에서 처리하여 성능을 높입니다.

```csharp
public async Task<Result<List<UserQuestInprogress>>> GetProgressQuestListAsync(long userId, Pageable pageable)
{
    try
    {
        // 캐시된 퀘스트 리스트가 있는지 확인
        var cache = await _memoryDb.GetCachedQuestList(userId);
        if (cache.IsSuccess)
        {
            return Result<List<UserQuestInprogress>>.Success(Pagination(cache.Value, pageable));
        }

        // 없다면 GameDB에서 가져옴
        var progressList = await _gameDb.GetProgressQuestList(userId);

        // 퀘스트 리스트를 캐싱
        if (await _memoryDb.CacheQuestList(userId, progressList) is var cacheQuest && cacheQuest.IsFailed)
        {
            return Result<List<UserQuestInprogress>>.Failure(cacheQuest.ErrorCode);
        }

        LogInfo(_logger, EventType.GetProgressQuest, "Get Progress Quest List", new { userId });
        
        // 데이터 반환
        return Result<List<UserQuestInprogress>>.Success(Pagination(progressList, pageable));
    }
    catch (Exception ex)
    {
        LogError(_logger, ErrorCode.FailedDataLoad, EventType.GetProgressQuest, 
            "Failed Get Progress Quest List", new { userId, ex.Message, ex.StackTrace });;
        return Result<List<UserQuestInprogress>>.Failure(ErrorCode.FailedDataLoad);       
    }
}
```

**Invalidate 쓰기 예시**


```csharp
public async Task<Result> RefreshQuestProgress(long userId, QuestType type, int addValue)
{
    try
    {
        // DB에서 진행중 퀘스트 조회
        var quests = await _gameDb.GetProgressQuestByType(userId, type);

        // 한 번의 순회로 완료/미완료 분리 + 갱신 진행도 저장
        var completed = new HashSet<long>();
        var updatedProgress = new Dictionary<long, int>(quests.Count);

        var questInfoMap = _masterDb.GetQuestInfoDatas(); 

        foreach (var q in quests)
        {
            var target = questInfoMap[q.quest_code];
            if (target.quest_type == QuestType.ClearStage)
            {
                if(addValue == target.quest_progress)
                    completed.Add(q.quest_code);
            }
            else
            {
                var newProgress = q.progress + addValue;
            
                if (newProgress >= target.quest_progress)
                    completed.Add(q.quest_code);
                else
                    updatedProgress[q.quest_code] = newProgress;    
            }
        }

        // 완료 처리 
        if (completed.Count > 0)
        {
            var ok = await _gameDb.CompleteQuest(userId, completed.ToList());
            if (!ok)
                return ErrorCode.FailedCompleteQuest;
        }

        // 기존 캐시 무효화
        if (await _memoryDb.DeleteCachedQuestList(userId) is var delete && delete.IsFailed)
        {
            return ErrorCode.FailedCacheGameData;
        }

        return Result.Success();
    }
    catch (Exception ex)
    {
        LogError(_logger, ErrorCode.FailedRefreshQuest, EventType.RefreshQuest,
            "Failed Refresh Quest Progress ", new { userId, ex.Message, ex.StackTrace });
        return Result.Failure(ErrorCode.FailedRefreshQuest);    
    }
}
```

---

## 3) 트랜잭션 처리

같은 트랜잭션에서 진행되어야 하는 경우(ex. 강화와 재화 소모 등) 하나의 트랜잭션으로 묶어서 처리를 진행합니다.
트랜잭션은 ErrorCode를 반환하게 되며, 성공 처리를 의미하는 ErrorCode.None이 반환되지 않는다면 Commit되지 않는 방식으로 처리됩니다.

**트랜잭션 래퍼**

```csharp
public async Task<ErrorCode> WithTransactionAsync(
    Func<QueryFactory, Task<ErrorCode>> action)
{
    var txOptions = new TransactionOptions
    {
        IsolationLevel = MapIsolation(IsolationLevel.ReadCommitted),
        Timeout = TransactionManager.DefaultTimeout
    };

    try
    {
        using var scope = new TransactionScope(
            TransactionScopeOption.Required,
            txOptions,
            TransactionScopeAsyncFlowOption.Enabled);

        EnsureOpen(); // scope 내부에서 open → 자동 enlist

        var ec = await action(_queryFactory);

        if (ec == ErrorCode.None)
        {
            scope.Complete();
            return ErrorCode.None;
        }

        // 실패 시 Complete() 안 하므로 롤백됨
        return ec;
    }
    catch (MySqlConnector.MySqlException ex) when (ex.Number == 1213 || ex.Number == 1205)
    {
        // Deadlock / Lock wait timeout → 재시도 1회
        return await WithTransactionAsync(action);
    }
    catch (Exception ex)
    {
        return ErrorCode.FailedTransaction; // 공용 에러코드 하나로 수렴
    }
}
```

**사용 예시**

```csharp
// 트랜잭션 처리
var txErrorCode = await _gameDb.WithTransactionAsync(async _ =>
{
    // 아이템 레벨 갱신
    if (await _gameDb.UpdateItemLevelAsync(userId, itemId, newLevel) == false)
    {
        return ErrorCode.FailedUpdateData;
    }

    // 유저 재화 갱신
    if (await _gameDb.UpdateUserCurrencyAsync(userId, newGold, gem) == false)
    {
        return ErrorCode.FailedUpdateGoldAndGem;
    }

    // 성공 코드 반환
    return ErrorCode.None;
});
```

> 읽기 전용 조회는 가능하면 트랜잭션 바깥에서 수행하고, 실제 변경 구간만 최소화합니다.

---

## 4) 로그 처리

`ILogger<T>` 기반의 ** LoggerManager **를 사용하고 있으며, 관련된 데이터를 함께 남깁니다.
로그는 Info/Error 두가지로 분류하여 관리하며, Error에서는 ErrorCode와 Exception 정보 등을 추가적으로 작성하여 디버깅을 용이하도록 합니다.
로그 파일은 날짜 별로 분류하여 저장되며, 로그 파일의 크기에 따라 여러개로 분류하여 보관합니다.

**기본 로깅 예시**

```csharp

// 일반 로그
LoggerManager.LogInfo(_logger, EventType.Login, "Request Login", new { request });

// 에러 로그
LoggerManager.LogError(_logger, ErrorCode.FailedRewardQuest, EventType.RewardQuest, "Failed Reward Quest", new { userId, questCode, ex.Message, ex.StackTrace });

```
